pipeline {
  agent { label 'conan_worker' }
  parameters {
    choice(name: 'Versions', choices: ['', '1.0', '2.0'], description: 'Target version to build')
    string(name: 'Architectures', defaultValue: 'release, debug', description: 'Which arch')
    string(name: 'Build_types', defaultValue: 'x86_64, i686', description: 'Build types')
  }
  stages {
    stage('Build') {
      steps {
        script {
          // Only run if a version was selected
          if ("${params.Versions}" == "") {
            echo "No version was selected, exiting"
          } else {
            p = load 'functions.groovy'
            def conanfile_path = p.conanfile_path("${env.SCRIPT_PATH}", "${params.Versions}")
            stash includeos: '*', name: 'all'
            def build_cmds = p.build("${params.Versions}", "${params.Architectures}", "${params.Build_types}", "${conanfile_path}")

            def builds = [:]

            build_cmds.each {
              builds["${it.key}"] = {
                node('conan_worker') {
                  stage("${it.key}") {
                    unstash 'all'
                    sh "${it.value}"
                  }
                }
              }
            }

            /*
            for (key in buildJobs.keySet()) {
              builds[key] = {
                node('conan_worker') {
                  stage(key) {
                    unstash 'all'
                    sh buildJobs[key]
                  }
                }
              }
            }
            */
            parallel builds

            //p.upload("http://internet.com")
          }
        }
      }
    }
  }
}
